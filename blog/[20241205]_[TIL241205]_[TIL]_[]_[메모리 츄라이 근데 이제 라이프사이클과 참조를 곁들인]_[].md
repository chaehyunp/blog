## UIViewController
- UIKit 앱의 뷰 계층을 관리하는 개체
- 한 개의 페이지는 반드시 한 개의 UIViewController를 가지고 내부에 UIKit의 UI클래스들을 배치하여 화면을 구성

## ViewController 생명주기
#### iOS의 대표 생명주기 2가지
1. App Lifecycle
2. ViewController Lifecycle  
1️⃣. init: 생성자  
2️⃣. loadView: UIViewController를 생성하면 반드시 하나의 뷰를 갖는데, 뷰가 메모리에 올라가기 전 사전 작업을 이때 진행됨  
3️⃣. viewDidLoad: 뷰가 메모리에 올라감, **메모리에 올라가기 위한 한 번만 호출**   
4️⃣. viewWillApear: 뷰가 메모리에 로드가 된 후 유저에게 보이기 직전, **여러 번 호출이 가능**(다른 화면에 갔다가 돌아오면 호출됨)  
5️⃣. viewIsApearing: 뷰가 유저에게 나타내고 있는 중...  
6️⃣. viewDidApear: 뷰가 유저에게 보여지는 상태  
7️⃣. viewWillDisappear: 뷰가 책임을 다 하고 사라질 것  
8️⃣. viewDidDisapear: 뷰가 사라짐  
9️⃣. deinit: 소멸자 



## 메모리 관리 이해
메모리와 디스크 모두 데이터의 저장 및 처리를 담당

▪️ **메모리 (RAM)**

- 휘발성 메모리
- 앱을 실행시키면 메모리에 올라가고 종료되면 앱과 함께 메모리에서 내려오게 된다.
- RAM이 클 수록 동시에 실행시킬 수 있는 앱의 총량이 높아진다.
- 디스크보다 속도가 빠르다. (CPU 가 디스크보다 메모리에 더 빨리 접근할 수 있다.)
- 디스크에 비해 용량이 작다.
- EEPROM 과 같은 비휘발성 메모리도 존재 -> 장치의 일련번호 및 하드웨어 정보를 저장

▪️ **디스크 (DISK)**
- 영구적인 데이터를 저장
- 앱 실행중에 디스크에 저장된 데이터들은 앱을 종료해도 디스크에 남는다.
- 파일, 문서, 프로그램 등 상대적으로 용량이 큰 정보들을 담을 수 있다.
- 메모리에 비해 속도가 느리다.
- `UserDefaults`, `CoreData` 를 활용해서 디스크에 데이터를 저장할 수 있다.


## Garbage Collector (GC)
Java에서 지원하는 메모리 관리를 돕는 시스템 중 하나. 메모리에 필요없는 것들을 정리해주는 역할을 한다. 사용하지 않는 데이터들이 메모리에 올라와 공간을 차지하고 있다면(Memory Leak) 매우 비효율적이므로 메모리 관리가 필수적이다.

GC는 메모리 영역에서 사용중인 것을 Mark하고, 마크되지 않는 데이터를 정리하는 Mark-and-Sweep 방식을 사용한다.

## Refrence Counting (RC)
Swift의 메모리 관리 시스템의 핵심. 인스턴스는 하나 이상의 참조자(소유자, owner)가 있어야 메모리에 유지된다. 인스턴스를 참조하고 있는 소유자의 개수를 `reference count` 라고 하고 이 개수가 `reference count > 0` 이면 메모리에 살아있고, `reference count = 0` 이면, 즉 소유자가 없다면 메모리에서 삭제된다.

클래스의 `deinit` 소멸자 메소드에서는 메모리가 해제 될 때 호출되는 것.

## ARC와 MRC
▪️ **ARC** Automatic Reference Counting  
- ARC 는 Swift 의 메모리 관리 시스템 (Java - GC, Swift - ARC)  
- Reference Count 를 자동으로 계산  
    - 객체가 생성될 때 RC 가 1 로 설정  
    - 객체가 다른 변수나 속성에 할당되어 참조될때마다 RC 가 1 씩 증가  
    - 객체에 대한 참조가 해제될때마다 RC 가 감소  
    - RC 0이 되면 더 이상 사용되지 않는 것으로 간주되어 메모리에서 해제  

▪️ **MRC** Manual Reference Counting  
- MRC 는 Objective-C 에서 사용하는 메모리 관리 시스템  
- Reference Count 를 개발자가 코드로 직접 계산  
    - 객체가 생성될때 개발자가 명시적으로 메모리 할당  
    - 객체를 다른 변수나 속성에 할당되어 참조될때마다 개발자가 명시적으로 RC 증가  
    - 객체에 대한 참조가 해제될때마다 개발자가 명시적으로 RC 감소  
    - RC 가 0이되면 개발자가 명시적으로 메모리에서 해제

## 약참조와 강참조
▪️ **약참조**
- Reference Count 를 증가시키지 않으면서 참조하는 것.
- weak 키워드를 붙여서 약참조를 할 수 있다.

▪️ **강참조**
- Reference Count 를 증가시키면서 참조하는 것.
- 일반적인 참조 방식을 말한다.